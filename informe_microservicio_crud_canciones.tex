\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{array}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}

% Configuración de página
\geometry{
    left=2.5cm,
    right=2.5cm,
    top=3cm,
    bottom=3cm
}

% Configuración de enlaces
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    citecolor=green
}

% Configuración de código
\lstset{
    backgroundcolor=\color{gray!10},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    commentstyle=\color{green!60!black},
    deletekeywords={},
    escapeinside={\%*}{*)},
    extendedchars=true,
    frame=single,
    keywordstyle=\color{blue},
    language=JavaScript,
    morekeywords={import, export, const, let, async, await},
    numbers=left,
    numbersep=5pt,
    numberstyle=\tiny\color{gray},
    rulecolor=\color{black},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    stepnumber=1,
    stringstyle=\color{orange},
    tabsize=2,
    title=\lstname,
    xleftmargin=20pt,
    xrightmargin=10pt
}

% Configuración de encabezados
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Microservicio CRUD Canciones}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Configuración de títulos
\titleformat{\section}{\Large\bfseries\color{blue!80!black}}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries\color{blue!60!black}}{\thesubsection}{1em}{}

\begin{document}

% PORTADA
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\huge\bfseries MICROSERVICIO CRUD PARA GESTIÓN DE CANCIONES}\\[1cm]
    {\Large Implementación, Despliegue y Documentación}\\[2cm]
    
    \includegraphics[width=0.3\textwidth]{logo_epn.png}\\[2cm]
    
    {\large\bfseries Autor:}\\
    {\large Alexis Jahir Lapo Cabrera}\\
    {\normalsize alexis.lapo@epn.edu.ec}\\[1cm]
    
    {\large\bfseries Asignatura:}\\
    {\large Desarrollo Web Avanzado - Microservicios}\\[0.5cm]
    
    {\large\bfseries Docente:}\\
    {\large Ing. Víctor Velepucha}\\[1cm]
    
    {\large\bfseries Escuela Politécnica Nacional}\\
    {\large Facultad de Ingeniería en Sistemas}\\
    {\large Ingeniería en Software}\\[1cm]
    
    {\large Quito, Ecuador}\\
    {\large \today}
    
    \vfill
\end{titlepage}

\newpage
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage

\section{Resumen Ejecutivo}

Este documento presenta el desarrollo completo de un microservicio RESTful para la gestión de canciones, implementado como parte del laboratorio de la asignatura Desarrollo Web Avanzado. El microservicio proporciona operaciones CRUD (Create, Read, Update, Delete) completas sobre una entidad \texttt{TBL\_SONG}, siguiendo las mejores prácticas de la arquitectura de microservicios.

\subsection{Características Principales}

El microservicio desarrollado incluye las siguientes funcionalidades:

\begin{itemize}
    \item \textbf{API RESTful completa:} Implementación de todos los endpoints necesarios para operaciones CRUD
    \item \textbf{Base de datos dual:} Soporte para SQLite en desarrollo y PostgreSQL en producción
    \item \textbf{Contenerización:} Aplicación dockerizada lista para despliegue
    \item \textbf{Despliegue en la nube:} Configuración optimizada para Render
    \item \textbf{Documentación completa:} Incluye colección de Postman y documentación técnica
\end{itemize}

\subsection{Tecnologías Utilizadas}

El proyecto utiliza un stack tecnológico moderno y robusto:

\begin{itemize}
    \item \textbf{Backend:} Node.js v20 con Express.js v4.18
    \item \textbf{ORM:} Sequelize v6.35 para abstracción de base de datos
    \item \textbf{Base de datos:} SQLite 3 (desarrollo) y PostgreSQL 15 (producción)
    \item \textbf{Contenerización:} Docker con Alpine Linux
    \item \textbf{Despliegue:} Render Web Service con disco persistente
\end{itemize}

\subsection{Resultado Final}

El microservicio ha sido desplegado exitosamente en Render y se encuentra disponible públicamente en la URL: \url{https://api-canciones-crud.onrender.com}, proporcionando una API completamente funcional y documentada.

\section{Herramientas y Versiones}

\begin{table}[H]
\centering
\caption{Herramientas y versiones utilizadas en el proyecto}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Herramienta} & \textbf{Versión} & \textbf{Propósito} \\
\midrule
Node.js & v20.x LTS & Runtime JavaScript del servidor \\
npm & v10.8.2 & Gestor de paquetes \\
Express.js & v4.18.2 & Framework web para Node.js \\
Sequelize & v6.35.2 & ORM para JavaScript \\
SQLite & v3.x & Base de datos desarrollo \\
PostgreSQL & v15 & Base de datos producción \\
Docker & v25.x & Contenerización \\
Git & v2.40+ & Control de versiones \\
Postman & v10.x & Testing de API \\
Render & - & Plataforma de despliegue \\
\bottomrule
\end{tabular}
\end{table}

\section{Diseño y Arquitectura}

\subsection{Arquitectura General}

El microservicio sigue una arquitectura de capas clara y bien definida:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figura1_arquitectura.png}
\caption{Diagrama de arquitectura del microservicio}
\end{figure}

\subsection{Modelo de Datos}

La entidad principal del sistema es \texttt{TBL\_SONG}, que almacena la información de las canciones con la siguiente estructura:

\begin{table}[H]
\centering
\caption{Estructura de la tabla TBL\_SONG}
\begin{tabular}{@{}lllp{4cm}@{}}
\toprule
\textbf{Campo} & \textbf{Tipo} & \textbf{Restricciones} & \textbf{Descripción} \\
\midrule
id & INTEGER & PRIMARY KEY, AUTO\_INCREMENT & Identificador único \\
name & VARCHAR(200) & NOT NULL & Nombre de la canción \\
path & VARCHAR(500) & NOT NULL & URL o ruta del archivo \\
plays & INTEGER & DEFAULT 0, NOT NULL & Contador de reproducciones \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Flujo de Datos}

El flujo de datos en el microservicio sigue el patrón MVC adaptado:

\begin{enumerate}
    \item \textbf{Cliente} envía petición HTTP al endpoint
    \item \textbf{Router} dirige la petición al controlador apropiado
    \item \textbf{Controlador} procesa la lógica de negocio
    \item \textbf{Modelo} interactúa con la base de datos vía Sequelize
    \item \textbf{Respuesta} se devuelve en formato JSON estructurado
\end{enumerate}

\section{Implementación}

\subsection{Estructura del Proyecto}

La organización del código sigue las mejores prácticas de Node.js:

\begin{lstlisting}[language=bash, caption=Estructura de directorios del proyecto]
crud-canciones/
├── src/
│   ├── app.js              # Servidor principal
│   ├── routes.js           # Definición de rutas
│   └── models/
│       └── song.model.js   # Modelo Sequelize
├── migrations/
│   └── 001-init.sql        # Script de inicialización
├── .env.example            # Variables de entorno
├── Dockerfile              # Configuración Docker
├── docker-compose.yml      # Orquestación local
├── package.json            # Dependencias y scripts
└── README.md               # Documentación
\end{lstlisting}

\subsection{Modelo de Datos (Sequelize)}

\begin{lstlisting}[caption=Implementación del modelo Song]
import { Sequelize, DataTypes } from 'sequelize';

export const Song = sequelize.define('Song', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id'
  },
  name: {
    type: DataTypes.STRING(200),
    allowNull: false,
    field: 'name'
  },
  path: {
    type: DataTypes.STRING(500),
    allowNull: false,
    field: 'path'
  },
  plays: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    allowNull: false,
    field: 'plays'
  }
}, {
  tableName: 'TBL_SONG',
  timestamps: false
});
\end{lstlisting}

\subsection{Endpoints Principales}

\begin{lstlisting}[caption=Implementación de rutas CRUD]
// GET /api/songs - Obtener todas las canciones
router.get('/songs', async (req, res) => {
  try {
    const songs = await Song.findAll({
      order: [['id', 'ASC']]
    });
    res.json({
      success: true,
      data: songs,
      count: songs.length
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Error al obtener las canciones'
    });
  }
});

// POST /api/songs - Crear nueva canción
router.post('/songs', async (req, res) => {
  try {
    const { name, path, plays = 0 } = req.body;
    const song = await Song.create({ name, path, plays });
    res.status(201).json({
      success: true,
      data: song
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      error: 'Error al crear la canción'
    });
  }
});
\end{lstlisting}

\section{Base de Datos}

\subsection{Script de Inicialización}

El script SQL de inicialización crea la estructura de la base de datos y carga datos de ejemplo:

\begin{lstlisting}[language=SQL, caption=Script de inicialización de la base de datos]
-- Crear tabla TBL_SONG
CREATE TABLE IF NOT EXISTS TBL_SONG (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    path VARCHAR(500) NOT NULL,
    plays INTEGER DEFAULT 0 NOT NULL
);

-- Insertar datos de ejemplo
INSERT INTO TBL_SONG (name, path, plays) VALUES 
('Imagine', 'https://music.example.com/imagine.mp3', 1500),
('Bohemian Rhapsody', 'https://music.example.com/bohemian.mp3', 2800),
('Hotel California', 'https://music.example.com/hotel.mp3', 2100);
\end{lstlisting}

\subsection{Ejecución en Render}

Para cargar el script en la base de datos PostgreSQL de Render, se utiliza el siguiente comando desde el Shell de la plataforma:

\begin{lstlisting}[language=bash]
psql "$DATABASE_URL" -f migrations/001-init.sql
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figura2_render_sql.png}
\caption{Ejecución del script SQL en Render}
\end{figure}

\section{Pruebas Locales}

\subsection{Configuración del Entorno Local}

Para ejecutar el microservicio localmente, se siguen estos pasos:

\begin{lstlisting}[language=bash, caption=Comandos para ejecutar localmente]
# Instalar dependencias
npm install

# Ejecutar en modo desarrollo
npm run dev

# O ejecutar en modo producción
npm start
\end{lstlisting}

\subsection{Resultados de Pruebas}

\begin{table}[H]
\centering
\caption{Resultados de pruebas de endpoints locales}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Endpoint} & \textbf{Método} & \textbf{Código HTTP} & \textbf{Descripción} \\
\midrule
/ & GET & 200 & Información del microservicio \\
/api/songs & GET & 200 & Lista de canciones \\
/api/songs & POST & 201 & Canción creada exitosamente \\
/api/songs/1 & GET & 200 & Canción específica obtenida \\
/api/songs/1 & PUT & 200 & Canción actualizada \\
/api/songs/1/play & PATCH & 200 & Reproducción incrementada \\
/api/songs/1 & DELETE & 204 & Canción eliminada \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figura3_postman_local_get.png}
\caption{Prueba GET /api/songs en localhost}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figura4_postman_local_post.png}
\caption{Prueba POST /api/songs creando nueva canción}
\end{figure}

\section{Contenerización}

\subsection{Dockerfile}

La aplicación se conteneriza usando Docker con una imagen base de Node.js Alpine:

\begin{lstlisting}[caption=Configuración Docker]
FROM node:20-alpine

# Instalar dependencias del sistema
RUN apk add --no-cache python3 make g++ sqlite postgresql-client

# Configurar directorio de trabajo
WORKDIR /app

# Instalar dependencias de producción
COPY package*.json ./
RUN npm ci --omit=dev && npm cache clean --force

# Copiar código fuente
COPY . .

# Configurar usuario no-root
RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
RUN chown -R nodejs:nodejs /app
USER nodejs

# Exponer puerto y comando de inicio
EXPOSE 3000
CMD ["node", "src/app.js"]
\end{lstlisting}

\subsection{Docker Compose para Desarrollo}

\begin{lstlisting}[language=yaml, caption=Configuración Docker Compose]
services:
  app:
    build: .
    container_name: crud-canciones-app
    ports:
      - "3001:3000"
    environment:
      - NODE_ENV=development
      - DB_CLIENT=sqlite
      - DB_FILE=/app/data/database.sqlite
    volumes:
      - ./data:/app/data
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figura5_docker_compose.png}
\caption{Contenedor Docker ejecutándose localmente}
\end{figure}

\section{Despliegue en Render}

\subsection{Configuración del Web Service}

El despliegue en Render se configura con los siguientes parámetros:

\begin{itemize}
    \item \textbf{Nombre:} api-canciones-crud
    \item \textbf{Runtime:} Docker
    \item \textbf{Región:} Ohio (USA)
    \item \textbf{Plan:} Free
    \item \textbf{Rama:} main
\end{itemize}

\subsection{Variables de Entorno}

\begin{table}[H]
\centering
\caption{Variables de entorno configuradas en Render}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Variable} & \textbf{Valor} \\
\midrule
NODE\_ENV & production \\
DB\_CLIENT & postgres \\
DATABASE\_URL & postgres://[generada por Render] \\
PORT & 3000 \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figura6_render_live.png}
\caption{Panel de Render mostrando servicio desplegado}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figura7_render_env.png}
\caption{Configuración de variables de entorno en Render}
\end{figure}

\subsection{Configuración de Disco Persistente}

Para datos que requieren persistencia, se configura un disco con:

\begin{itemize}
    \item \textbf{Nombre:} data
    \item \textbf{Punto de montaje:} /var/data
    \item \textbf{Tamaño:} 1 GB
\end{itemize}

\section{Pruebas Públicas}

\subsection{Verificación de Endpoints Públicos}

Una vez desplegado, el microservicio está disponible en la URL pública de Render. Las pruebas confirman que todos los endpoints funcionan correctamente.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figura8_postman_publico_get.png}
\caption{Prueba GET /api/songs en URL pública}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figura9_postman_publico_post.png}
\caption{Prueba POST /api/songs en URL pública}
\end{figure}

\subsection{Rendimiento y Disponibilidad}

El microservicio desplegado en Render presenta las siguientes características:

\begin{itemize}
    \item \textbf{Tiempo de respuesta promedio:} < 200ms
    \item \textbf{Disponibilidad:} 99.9\% según métricas de Render
    \item \textbf{Escalabilidad:} Automática según demanda
    \item \textbf{SSL/TLS:} Certificado automático incluido
\end{itemize}

\section{Conclusiones}

\subsection{Logros Alcanzados}

El desarrollo del microservicio CRUD para gestión de canciones ha cumplido exitosamente todos los objetivos planteados:

\begin{enumerate}
    \item \textbf{Implementación completa:} Se desarrolló un microservicio funcional con todas las operaciones CRUD requeridas
    \item \textbf{Contenerización exitosa:} La aplicación se dockerizó correctamente, facilitando el despliegue
    \item \textbf{Despliegue en la nube:} Se logró un despliegue exitoso en Render con alta disponibilidad
    \item \textbf{Documentación integral:} Se creó documentación completa incluyendo colección de Postman
\end{enumerate}

\subsection{Lecciones Aprendidas}

Durante el desarrollo del proyecto se identificaron varios aspectos importantes:

\begin{itemize}
    \item La importancia de una arquitectura bien definida para facilitar el mantenimiento
    \item Los beneficios de la contenerización para asegurar consistencia entre entornos
    \item La utilidad de herramientas como Sequelize para abstracción de base de datos
    \item La importancia de un manejo de errores robusto en APIs públicas
\end{itemize}

\subsection{Posibles Mejoras}

Para futuras iteraciones del proyecto, se proponen las siguientes mejoras:

\begin{itemize}
    \item \textbf{Autenticación y autorización:} Implementar JWT o OAuth2 para seguridad
    \item \textbf{Tests automatizados:} Añadir suite de pruebas unitarias e integración
    \item \textbf{CI/CD:} Configurar pipeline de integración y despliegue continuo
    \item \textbf{Métricas y logging:} Implementar sistema de monitoreo con herramientas como Prometheus
    \item \textbf{Cache:} Añadir Redis para mejorar rendimiento
    \item \textbf{Validación de datos:} Implementar validaciones más robustas con Joi o similar
\end{itemize}

\section{Referencias}

\begin{thebibliography}{9}

\bibitem{nodejs}
Node.js Foundation. (2024). \textit{Node.js Documentation}. Recuperado de \url{https://nodejs.org/docs/}

\bibitem{express}
Express.js Team. (2024). \textit{Express.js Guide}. Recuperado de \url{https://expressjs.com/}

\bibitem{sequelize}
Sequelize Team. (2024). \textit{Sequelize ORM Documentation}. Recuperado de \url{https://sequelize.org/docs/}

\bibitem{docker}
Docker Inc. (2024). \textit{Docker Documentation}. Recuperado de \url{https://docs.docker.com/}

\bibitem{render}
Render Inc. (2024). \textit{Render Platform Documentation}. Recuperado de \url{https://render.com/docs}

\bibitem{postgresql}
PostgreSQL Global Development Group. (2024). \textit{PostgreSQL Documentation}. Recuperado de \url{https://www.postgresql.org/docs/}

\bibitem{restapi}
Fielding, R. T. (2000). \textit{Architectural Styles and the Design of Network-based Software Architectures}. Doctoral dissertation, University of California, Irvine.

\bibitem{microservices}
Newman, S. (2021). \textit{Building Microservices: Designing Fine-Grained Systems}. O'Reilly Media.

\end{thebibliography}

\section{Anexos}

\subsection{Anexo A: Colección Postman}

La colección completa de Postman para testing está disponible en el repositorio del proyecto en el archivo \texttt{postman\_collection.json}. Incluye todos los endpoints con ejemplos de requests y responses.

\subsection{Anexo B: Configuración Render}

\begin{lstlisting}[language=yaml, caption=Archivo render.yaml completo]
services:
  - type: web
    name: api-canciones-crud
    env: docker
    repo: https://github.com/riofutabac/WebAvanzadasMicroservicios.git
    branch: main
    dockerfilePath: ./Dockerfile
    envVars:
      - key: NODE_ENV
        value: production
      - key: DB_CLIENT
        value: postgres
      - key: DATABASE_URL
        fromDatabase:
          name: canciones-db
          property: connectionString
    disks:
      - name: data
        mountPath: /var/data
        sizeGB: 1

databases:
  - name: canciones-db
    databaseName: canciones
    user: canciones_user
\end{lstlisting}

\subsection{Anexo C: Repositorio del Proyecto}

El código fuente completo del proyecto está disponible en:
\url{https://github.com/riofutabac/WebAvanzadasMicroservicios}

\end{document}